# SQLServerのインデックスについて

## 参考サイト
* [Yet Another Brain: SQL Serverのインデックス設計基準](http://takumayokoo.blogspot.jp/2011/02/sql-server_26.html)
* [第 1 回 「インデックスアーキテクチャとデータアクセス方法を理解する」～ システム構築 ～](http://msdn.microsoft.com/ja-jp/library/Cc707364)
* [インデックスの基礎](http://technet.microsoft.com/ja-jp/library/ms190457(v=sql.105).aspx)
* [いまさら聞けないSQL Server 2005のインデックス　その３ - Bug Catharsis](http://zecl.hatenablog.com/entry/20080224/p5)
* [非クラスタ化インデックスの構造](http://technet.microsoft.com/ja-jp/library/ms177484(v=sql.105).aspx)
* [SQL Server 2000 チューニング全工程（4）：SQL Serverのインデックス構造（前編） (1/2) - ＠IT](http://www.atmarkit.co.jp/ait/articles/0501/18/news097.html)
* [SQL Server 2000 チューニング全工程（5）：SQL Serverのインデックス構造（後編） (1/2) - ＠IT](http://www.atmarkit.co.jp/ait/articles/0503/18/news123.html)

## インデックス

### クラスタ化インデックス
* クラスタ化インデックスが含まれるテーブル：「クラスタ化テーブル」
* クラスタ化インデックスが含まれないテーブル：「ヒープ」

### 非クラスタ化インデックス
* 完全一致検索に強い
* 範囲検索(レンジスキャン)に弱い＝未ソート
* 非クラスタ化インデックスのリーフレベルには非クラスタ化キー値または行ロケータが格納される
* 非クラスタ化インデックスは2種類ある
    * クラスタ化テーブルに追加するパターン
    クラスタ化インデックスにより物理的なソートが走るので、必ずクラスタ化インデックスを作成した後に非クラスタ化インデックスを作成する
    * ヒープに追加するパターン
* 行ロケータ：非クラスタ化インデックス内のインデックス行からデータ行を指すポインタ(RID:行識別子＝物理的なキー)のこと
* データがヒープに格納されている場合：行ロケータ＝行を指すポインタ
* データがクラスタ化テーブルに格納されている場合：行ロケータ＝クラスタ化インデックスキー

**非クラスタ化インデックスとクラスタ化インデックスを併用で高速になパターン**
![fig1](http://image.itmedia.co.jp/ait/articles/0503/18/l_r12fig02.gif)

**レンジスキャンが遅い理由**

* 日付で範囲検索するケースを考えると、日付範囲内のデータを検索するには非クラスタ化インデックスのリーフレベルに格納されている行ロケータ(＝行へのポインタ)でデータページを何度も検索する(＝Bookmaark Lookup:RIDを元にヒープのデータ行を読みに行く操作)ため遅い。
* これを解決するにはカバリングインデックスを利用する。

**非クラスタ化インデックスでレンジスキャンが遅いパターン**
![fig2](http://image.itmedia.co.jp/ait/articles/0503/18/l_r12fig03.gif)

### カバリングインデックス
* SELECTをインデックスだけで成立させる手法。テーブルにアクセスしないので高速。
* 通常のインデックスの場合、WHERE句に指定した条件のみだが、取得する列にもインデックスを適用することで完全にインデックスだけで完結させられる。
* ただし、サイズがでかくなる。

### 付加列インデックス
* 条件式に使用する列に張ったインデックス以外に取得列に対して付加的に追加するインデックス。
* カバリングインデックスを実現するもう一つの方法。